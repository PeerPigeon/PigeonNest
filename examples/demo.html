<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>PigeonNest Demo - Vue 3 Framework for PeerPigeon</title>
  <link rel="icon" type="image/jpeg" href="../pigeonlogo.jpg">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }
    
    #app {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
    }
    
    .demo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .demo-section {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .demo-section h2 {
      font-size: 18px;
      margin-bottom: 16px;
      color: #333;
      border-bottom: 2px solid #1976d2;
      padding-bottom: 8px;
    }
    
    .control-group {
      margin-bottom: 16px;
    }
    
    .control-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: #666;
      font-size: 14px;
    }
    
    input[type="text"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      font-size: 14px;
    }
    
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button.primary {
      background: #1976d2;
      color: white;
    }
    
    button.primary:hover:not(:disabled) {
      background: #1565c0;
    }
    
    button.secondary {
      background: #f5f5f5;
      color: #333;
      border: 1px solid #e0e0e0;
    }
    
    button.secondary:hover:not(:disabled) {
      background: #e0e0e0;
    }
    
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .button-group {
      display: flex;
      gap: 8px;
    }
    
    .message-log {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 12px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 13px;
      font-family: monospace;
    }
    
    .message-item {
      padding: 6px 0;
      border-bottom: 1px solid #e0e0e0;
    }
    
    .message-item:last-child {
      border-bottom: none;
    }
    
    .streams-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .message-history {
      margin-top: 16px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: #fafafa;
      padding: 12px;
    }

    .message-history-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .message-history-header h3 {
      margin: 0;
      font-size: 16px;
      color: #333;
    }

    .history-count {
      background: #e3f2fd;
      color: #1976d2;
      padding: 2px 10px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 600;
    }

    .history-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 220px;
      overflow-y: auto;
    }

    .history-item {
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 10px;
      background: #fff;
    }

    .history-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #666;
      margin-bottom: 6px;
    }

    .history-direction {
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .history-direction.sent {
      color: #1976d2;
    }

    .history-direction.received {
      color: #2e7d32;
    }

    .history-peer {
      font-family: monospace;
    }

    .history-content {
      font-size: 13px;
      color: #333;
      word-break: break-word;
    }

    .history-empty {
      padding: 16px;
      text-align: center;
      font-size: 13px;
      color: #999;
      border: 1px dashed #e0e0e0;
      border-radius: 4px;
      background: #fff;
    }
  </style>
</head>
<body>
  <div id="app">
    <h1><img src="../pigeonlogo.jpg" alt="PigeonNest" style="width: 40px; height: 40px; vertical-align: middle; border-radius: 50%; margin-right: 12px;">PigeonNest Demo</h1>
    <p style="text-align: center; color: #666; margin-bottom: 30px;">
      Vue 3 Framework for PeerPigeon - WebRTC Mesh Networking with Streaming
    </p>
    
    <div class="demo-grid">
      <!-- Connection Control -->
      <div class="demo-section">
        <h2>Connection</h2>
        <hub-connection
          v-model:hub-url="hubUrl"
          v-model:network-name="networkName"
          :is-initialized="isInitialized"
          :is-connected="isConnected"
          @initialize="initialize"
          @connect="connectToHub"
          @disconnect="disconnect"
        />
      </div>
      
      <!-- Status -->
      <div class="demo-section">
        <h2>Status</h2>
        <peer-connection-status 
          :status="status" 
          :is-connected="isConnected"
        />
      </div>
    </div>
    
    <div class="demo-grid">
      <!-- Peers List -->
      <div class="demo-section">
        <h2>Connected Peers</h2>
        <peer-list 
          :peers="connectedPeerIds.map(id => ({ peerId: id, discoveredAt: Date.now() }))"
          @select="selectedPeer = $event"
          :selected-peer-id="selectedPeer"
          :show-message-action="false"
          :show-file-action="false"
        />
      </div>
      
      <!-- File Upload -->
      <div class="demo-section">
        <h2>üìÅ Send Files</h2>
        <file-sender 
          :peers="connectedPeerIds"
          @send="handleFileSend"
        />
      </div>
      
      <!-- Messaging -->
      <div class="demo-section">
        <chat-section
          :messages="messageHistory"
          :peers="connectedPeerIds"
          :disabled="!isConnected"
          @send="handleChatSend"
        />
      </div>
    </div>
    
    <!-- Active Streams -->
    <div v-if="activeStreamsArray.length > 0" class="demo-section">
      <h2>Active Transfers</h2>
      <stream-container
        :streams="activeStreamsArray"
        @cancel="cancelStream"
        @dismiss="dismissStream"
        @download="downloadFile"
      />
    </div>
    
    <!-- Message Log -->
    <div class="demo-section">
      <h2>Event Log</h2>
      <event-log :messages="messages" />
    </div>
  </div>

  <script type="module">
  import { createApp, ref, computed, onUnmounted } from 'vue/dist/vue.esm-bundler.js'
    import { 
      usePeerPigeon, 
      usePeerStreaming,
      PeerConnectionStatus,
      PeerList,
      FileUpload,
      FileSender,
      StreamProgress,
      StreamContainer,
      MessageInput,
      MessageHistory,
      PeerSelector,
      HubConnection,
      EventLog,
      ChatSection
    } from '../src/index.ts'
    
    const app = createApp({
      components: {
        PeerConnectionStatus,
        PeerList,
        FileUpload,
        FileSender,
        StreamProgress,
        StreamContainer,
        MessageInput,
        MessageHistory,
        PeerSelector,
        HubConnection,
        EventLog,
        ChatSection
      },
      setup() {
        const hubUrl = ref('wss://pigeonhub.fly.dev')
        const networkName = ref('pigeonnest-demo')
        const selectedPeer = ref(null)
        const fileTargetPeer = ref('')
        const selectedFilesSimple = ref([])
        const fileInputRef = ref(null)
        const messages = ref([])
        const messageHistory = ref([])
        
        const messageText = ref('')

        const {
          mesh,
          status,
          isConnected,
          isInitialized,
          connectedPeerIds,
          discoveredPeers,
          init,
          connect,
          disconnect: disconnectMesh,
          sendMessage,
          sendToMultiplePeers,
          sendToTarget,
          broadcast,
          onMessage
        } = usePeerPigeon({
          networkName: networkName.value,
          maxPeers: 5,
          minPeers: 1,
          enableCrypto: true
        })
        
        const {
          activeStreams,
          sendFile,
          sendFileToMultiplePeers,
          sendFilesToTarget,
          sendBlob,
          receiveStream,
          cancelStream: cancelStreamComposable
        } = usePeerStreaming()
        
        const addMessage = (text) => {
          messages.value.unshift({
            text,
            timestamp: Date.now()
          })
          if (messages.value.length > 50) {
            messages.value = messages.value.slice(0, 50)
          }
        }

        let unsubscribeMessage = null
        
        const initialize = async () => {
          try {
            await init()
            addMessage('‚úÖ Mesh initialized')

            if (unsubscribeMessage) {
              unsubscribeMessage()
            }

            unsubscribeMessage = onMessage((event) => {
              console.log('üîç Message event received:', event)
              
              const from = event.from || 'unknown'
              
              // Extract content properly - PeerPigeon wraps it in an object
              let content = event.content
              if (typeof content === 'object') {
                // Check for encrypted message
                if (content.encrypted && content.data) {
                  content = content.data
                } else if (content.message) {
                  content = content.message
                } else if (content.broadcast && content.data) {
                  content = content.data
                } else {
                  content = JSON.stringify(content)
                }
              }
              
              const displayContent = typeof content === 'string' ? content : JSON.stringify(content)
              
              addMessage(`üí¨ Message from ${from.substring(0, 8)}...: ${displayContent}`)
              messageHistory.value.unshift({
                direction: 'received',
                peerId: event.from,
                content: displayContent,
                timestamp: Date.now()
              })
              if (messageHistory.value.length > 20) {
                messageHistory.value = messageHistory.value.slice(0, 20)
              }
            })
            
            // Set up event listeners
            if (mesh.value) {
              mesh.value.addEventListener('peerConnected', (e) => {
                addMessage(`üîó Peer connected: ${e.peerId.substring(0, 8)}...`)
              })
              
              mesh.value.addEventListener('peerDisconnected', (e) => {
                addMessage(`‚ùå Peer disconnected: ${e.peerId.substring(0, 8)}...`)
              })
              
              mesh.value.addEventListener('cryptoReady', () => {
                addMessage('üîê Encryption system ready')
                console.log('üîê Crypto system initialized')
              })
              
              mesh.value.addEventListener('peerKeyAdded', (e) => {
                addMessage(`üîê Key exchange completed with ${e.peerId.substring(0, 8)}...`)
                console.log('üîê Key added for peer:', e.peerId)
              })
              
              mesh.value.addEventListener('cryptoError', (e) => {
                addMessage(`‚ùå Crypto error: ${e.error}`)
                console.error('üîê Crypto error:', e)
              })
              
              mesh.value.addEventListener('streamReceived', async (e) => {
                addMessage(`üì• Receiving file: ${e.metadata.filename}`)
                try {
                  const blob = await receiveStream(e)
                  addMessage(`‚úÖ File received: ${e.metadata.filename} (${(blob.size / 1024).toFixed(2)} KB)`)
                  
                  // Store the blob for download button
                  const stream = activeStreams.value.get(e.streamId)
                  if (stream) {
                    stream.receivedBlob = blob
                  }
                } catch (err) {
                  addMessage(`‚ùå Error receiving file: ${err.message}`)
                }
              })
            }
          } catch (err) {
            addMessage(`‚ùå Initialization failed: ${err.message}`)
          }
        }
        
        const connectToHub = async () => {
          try {
            await connect(hubUrl.value)
            addMessage(`‚úÖ Connected to hub: ${hubUrl.value}`)
          } catch (err) {
            addMessage(`‚ùå Connection failed: ${err.message}`)
          }
        }
        
        const disconnect = () => {
          disconnectMesh()
          addMessage('üîå Disconnected')
        }
        
        const handleFileUpload = async (files, targetPeerId) => {
          const target = targetPeerId !== undefined ? targetPeerId : selectedPeer.value
          
          // Check if target is empty string (placeholder) - treat as no selection
          if (target === '' || target === undefined) {
            addMessage('‚ùå No target selected')
            return
          }
          
          try {
            if (target === null) {
              // Broadcast to all peers
              addMessage(`üì¢ Broadcasting ${files.length} file(s) to all peers...`)
              await sendFilesToTarget(mesh.value, connectedPeerIds.value, files)
              addMessage(`‚úÖ Broadcast complete`)
            } else if (Array.isArray(target)) {
              // Send to multiple peers
              addMessage(`üì§ Sending ${files.length} file(s) to ${target.length} peers...`)
              await sendFilesToTarget(mesh.value, target, files)
              addMessage(`‚úÖ Sent to ${target.length} peers`)
            } else {
              // Send to single peer
              for (const file of files) {
                addMessage(`üì§ Sending ${file.name} to ${target.substring(0, 8)}...`)
                await sendFile(mesh.value, target, file)
                addMessage(`‚úÖ Sent ${file.name}`)
              }
            }
          } catch (err) {
            addMessage(`‚ùå Failed to send: ${err.message}`)
          }
        }

        const handleSendMessage = async (message, targetPeer) => {
          if (!mesh.value) {
            addMessage('‚ùå Mesh not initialized')
            return
          }
          
          try {
            if (targetPeer === null) {
              // Broadcast
              await broadcast(message)
              addMessage(`üì¢ Broadcast: ${message}`)
              messageHistory.value.unshift({
                direction: 'sent',
                peerId: 'broadcast',
                content: message,
                timestamp: Date.now()
              })
            } else if (Array.isArray(targetPeer)) {
              // Multiple peers
              await sendToMultiplePeers(targetPeer, message)
              addMessage(`üì§ Sent to ${targetPeer.length} peers: ${message}`)
              for (const peerId of targetPeer) {
                messageHistory.value.unshift({
                  direction: 'sent',
                  peerId: peerId,
                  content: message,
                  timestamp: Date.now()
                })
              }
            } else {
              // Single peer
              await sendMessage(targetPeer, message)
              addMessage(`ÔøΩ Sent to ${targetPeer.substring(0, 8)}...: ${message}`)
              messageHistory.value.unshift({
                direction: 'sent',
                peerId: targetPeer,
                content: message,
                timestamp: Date.now()
              })
            }
            if (messageHistory.value.length > 20) {
              messageHistory.value = messageHistory.value.slice(0, 20)
            }
          } catch (err) {
            addMessage(`‚ùå Failed to send message: ${err.message}`)
          }
        }

        const handleChatSend = async (message, target) => {
          if (!mesh.value) {
            addMessage('‚ùå Mesh not initialized')
            return
          }
          
          try {
            if (target === null) {
              // Broadcast
              await broadcast(message)
              addMessage(`üì¢ Broadcast: ${message}`)
              messageHistory.value.unshift({
                direction: 'sent',
                peerId: 'broadcast',
                content: message,
                timestamp: Date.now()
              })
            } else {
              // Single peer
              await sendMessage(target, message)
              addMessage(`üì§ Sent to ${target.substring(0, 8)}...: ${message}`)
              messageHistory.value.unshift({
                direction: 'sent',
                peerId: target,
                content: message,
                timestamp: Date.now()
              })
            }
            if (messageHistory.value.length > 50) {
              messageHistory.value = messageHistory.value.slice(0, 50)
            }
          } catch (err) {
            addMessage(`‚ùå Failed to send message: ${err.message}`)
          }
        }

        const handleFileSend = async (files, target) => {
          if (!mesh.value) {
            addMessage('‚ùå Mesh not initialized')
            return
          }

          try {
            if (target === null) {
              // Broadcast to all peers
              addMessage(`üì¢ Broadcasting ${files.length} file(s) to all peers...`)
              for (const file of files) {
                for (const peerId of connectedPeerIds.value) {
                  await sendFile(mesh.value, peerId, file)
                }
              }
              addMessage(`‚úÖ Broadcast complete`)
            } else {
              // Send to single peer
              for (const file of files) {
                addMessage(`üì§ Sending ${file.name} to ${target.substring(0, 8)}...`)
                await sendFile(mesh.value, target, file)
                addMessage(`‚úÖ Sent ${file.name}`)
              }
            }
          } catch (err) {
            addMessage(`‚ùå Failed to send: ${err.message}`)
          }
        }

        const handleFileSelectSimple = (event) => {
          const files = Array.from(event.target.files || [])
          selectedFilesSimple.value.push(...files)
        }

        const removeFileSimple = (index) => {
          selectedFilesSimple.value.splice(index, 1)
        }

        const clearFilesSimple = () => {
          selectedFilesSimple.value = []
          if (fileInputRef.value) {
            fileInputRef.value.value = ''
          }
        }

        const formatFileSizeSimple = (bytes) => {
          if (bytes === 0) return '0 B'
          const k = 1024
          const sizes = ['B', 'KB', 'MB', 'GB']
          const i = Math.floor(Math.log(bytes) / Math.log(k))
          return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`
        }

        const uploadFilesSimple = async () => {
          if (!fileTargetPeer.value || fileTargetPeer.value === '') {
            addMessage('‚ùå No target selected')
            return
          }

          try {
            if (fileTargetPeer.value === '__broadcast__') {
              // Broadcast to all peers
              addMessage(`üì¢ Broadcasting ${selectedFilesSimple.value.length} file(s) to all peers...`)
              for (const file of selectedFilesSimple.value) {
                for (const peerId of connectedPeerIds.value) {
                  await sendFile(mesh.value, peerId, file)
                }
              }
              addMessage(`‚úÖ Broadcast complete`)
            } else {
              // Send to single peer
              for (const file of selectedFilesSimple.value) {
                addMessage(`üì§ Sending ${file.name} to ${fileTargetPeer.value.substring(0, 8)}...`)
                await sendFile(mesh.value, fileTargetPeer.value, file)
                addMessage(`‚úÖ Sent ${file.name}`)
              }
            }
            clearFilesSimple()
          } catch (err) {
            addMessage(`‚ùå Failed to send: ${err.message}`)
          }
        }

        const uploadFilesComponent = async (files, targetPeerId) => {
          const target = targetPeerId !== undefined ? targetPeerId : fileTargetPeer.value
          
          if (!target || target === '') {
            addMessage('‚ùå No target selected')
            return
          }

          try {
            if (target === null) {
              // Broadcast to all peers
              addMessage(`üì¢ Broadcasting ${files.length} file(s) to all peers...`)
              for (const file of files) {
                for (const peerId of connectedPeerIds.value) {
                  await sendFile(mesh.value, peerId, file)
                }
              }
              addMessage(`‚úÖ Broadcast complete`)
            } else if (Array.isArray(target)) {
              // Multiple peers
              addMessage(`üì§ Sending ${files.length} file(s) to ${target.length} peers...`)
              for (const file of files) {
                for (const peerId of target) {
                  await sendFile(mesh.value, peerId, file)
                }
              }
              addMessage(`‚úÖ Sent to ${target.length} peers`)
            } else {
              // Single peer
              for (const file of files) {
                addMessage(`üì§ Sending ${file.name} to ${target.substring(0, 8)}...`)
                await sendFile(mesh.value, target, file)
                addMessage(`‚úÖ Sent ${file.name}`)
              }
            }
          } catch (err) {
            addMessage(`‚ùå Failed to send: ${err.message}`)
          }
        }

        const cancelStream = (streamId) => {
          cancelStreamComposable(streamId)
          addMessage(`üö´ Cancelled stream: ${streamId}`)
        }
        
        const dismissStream = (streamId) => {
          activeStreams.value.delete(streamId)
          activeStreams.value = new Map(activeStreams.value)
        }
        
        const downloadFile = (streamOrId) => {
          // Handle both stream object and streamId string for backward compatibility
          const stream = typeof streamOrId === 'string' 
            ? activeStreams.value.get(streamOrId)
            : streamOrId
          
          if (stream && stream.receivedBlob) {
            const url = URL.createObjectURL(stream.receivedBlob)
            const a = document.createElement('a')
            a.href = url
            a.download = stream.metadata?.filename || stream.filename || 'download'
            a.click()
            URL.revokeObjectURL(url)
            addMessage(`üíæ Downloaded: ${stream.metadata?.filename || stream.filename}`)
          }
        }
        
        const activeStreamsArray = computed(() => 
          Array.from(activeStreams.value.values())
        )
        
        const formatTime = (timestamp) => {
          const date = new Date(timestamp)
          return date.toLocaleTimeString()
        }

        const formatPeerId = (peerId) => {
          if (!peerId) return 'unknown'
          if (peerId.length <= 16) return peerId
          return `${peerId.substring(0, 8)}...${peerId.substring(peerId.length - 4)}`
        }
        
        onUnmounted(() => {
          if (unsubscribeMessage) {
            unsubscribeMessage()
            unsubscribeMessage = null
          }
        })
        
        return {
          hubUrl,
          networkName,
          selectedPeer,
          fileTargetPeer,
          selectedFilesSimple,
          fileInputRef,
          messages,
          messageHistory,
          messageText,
          status,
          isConnected,
          isInitialized,
          connectedPeerIds,
          discoveredPeers,
          activeStreamsArray,
          initialize,
          connectToHub,
          disconnect,
          handleFileUpload,
          handleFileSend,
          handleFileSelectSimple,
          removeFileSimple,
          clearFilesSimple,
          formatFileSizeSimple,
          uploadFilesSimple,
          uploadFilesComponent,
          handleSendMessage,
          handleChatSend,
          cancelStream,
          dismissStream,
          downloadFile,
          formatTime,
          formatPeerId
        }
      }
    })
    
    app.mount('#app')
  </script>
</body>
</html>
